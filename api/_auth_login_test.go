
// ********RoostGPT********
/*
Test generated by RoostGPT for test improve-test-golang using AI Type Open AI and AI Model gpt-4o

ROOST_METHOD_HASH=login_b45c9ba5a0
ROOST_METHOD_SIG_HASH=login_5743050a86

FUNCTION_DEF=func (server *Server) login(ctx *gin.Context)
Certainly! Below are the test scenarios for the `login` function from the Go code provided:

### Scenario 1: Successful Login

**Details:**
- **Description:** This test checks if a user can successfully log in with valid credentials. It verifies that the function generates a JWT token and returns an HTTP 200 status.
- **Execution:**
  - **Arrange:** Set up a mock database with a user having a known username and password. Mock the `GetUser` method to return this user when queried.
  - **Act:** Call the `login` function with a `gin.Context` containing the correct username and password.
  - **Assert:** Check that the response status is HTTP 200 and a JWT token is returned.
- **Validation:**
  - The assertion checks that the login process correctly authenticates the user and generates a token, which is crucial for accessing protected resources.

### Scenario 2: Invalid Username

**Details:**
- **Description:** This test checks the behavior when the user tries to log in with a username that does not exist in the database.
- **Execution:**
  - **Arrange:** Mock the `GetUser` method to return an `sql.ErrNoRows` error for a non-existent username.
  - **Act:** Invoke the `login` function with a `gin.Context` containing a non-existent username.
  - **Assert:** Verify that the response status is HTTP 404.
- **Validation:**
  - Ensures that the system correctly identifies non-existent users and responds with the appropriate error, maintaining security by not disclosing unnecessary information.

### Scenario 3: Incorrect Password

**Details:**
- **Description:** This test verifies the function's response to a valid username but an incorrect password.
- **Execution:**
  - **Arrange:** Set up a mock user with a known password in the database. Mock the `GetUser` method to return this user. Use an incorrect password in the request.
  - **Act:** Call the `login` function with the correct username and incorrect password.
  - **Assert:** Check that the response status is HTTP 401.
- **Validation:**
  - Tests the password verification logic, ensuring that incorrect passwords are not accepted, thus safeguarding user accounts.

### Scenario 4: Password Hash Comparison Error

**Details:**
- **Description:** This test checks the behavior when the password hash comparison fails due to internal issues (e.g., malformed stored hash).
- **Execution:**
  - **Arrange:** Mock the `GetUser` method to return a user with a malformed password hash.
  - **Act:** Call the `login` function with the correct username and password.
  - **Assert:** Verify that the response status is HTTP 401.
- **Validation:**
  - Confirms that the system handles unexpected hash comparison failures gracefully, maintaining robustness.

### Scenario 5: JWT Token Generation Error

**Details:**
- **Description:** This test checks the function's response when there is an error in generating the JWT token.
- **Execution:**
  - **Arrange:** Mock the token signing process to force an error (e.g., using an invalid signing key).
  - **Act:** Call the `login` function with valid credentials.
  - **Assert:** Verify that the response status is HTTP 500.
- **Validation:**
  - Ensures that the system correctly handles unexpected token generation failures, maintaining stability and informing the user of an internal issue.

### Scenario 6: Invalid JSON Request Body

**Details:**
- **Description:** This test verifies the function's response to an invalid JSON format in the request body.
- **Execution:**
  - **Arrange:** Prepare a `gin.Context` with a malformed JSON body.
  - **Act:** Call the `login` function with this context.
  - **Assert:** Check that the response status is HTTP 400.
- **Validation:**
  - Ensures the function correctly validates input formats, preventing potential injection attacks or processing errors.

### Scenario 7: Database Connection Error

**Details:**
- **Description:** This test checks how the function behaves when there is a database connection error during user retrieval.
- **Execution:**
  - **Arrange:** Mock the `GetUser` method to simulate a database connection error.
  - **Act:** Invoke the `login` function with a valid username.
  - **Assert:** Verify that the response status is HTTP 500.
- **Validation:**
  - Confirms that the function can handle database connectivity issues gracefully, maintaining application stability.

These scenarios cover a wide range of potential situations to ensure the `login` function operates correctly under various conditions, focusing on both successful and erroneous cases.

roost_feedback [1/30/2025, 6:31:10 PM]:add negative scenarios
*/

// ********RoostGPT********

package api

import (
	"bytes"
	"context"
	"crypto/sha512"
	"database/sql"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v4"
	"golang.org/x/crypto/bcrypt"
)

type SQLStore struct {
	db *sql.DB
	*Queries
}

type Queries struct {
	db *sql.DB
}

func (q *Queries) GetUser(ctx context.Context, username string) (User, error) {
	return User{}, nil
}

type Server struct {
	store  *SQLStore
	router *gin.Engine
}

type User struct {
	ID        int32
	Username  string
	Password  string
	Email     string
	CreatedAt time.Time
}

type loginRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required"`
}

type Claims struct {
	Username string `json:"username"`
	jwt.RegisteredClaims
}

func errorResponse(err error) gin.H {
	return gin.H{"error": err.Error()}
}

func (server *Server) login(ctx *gin.Context) {
	var req loginRequest
	err := ctx.ShouldBindJSON(&req)
	if err != nil {
		ctx.JSON(http.StatusBadRequest, errorResponse(err))
		return
	}

	user, err := server.store.GetUser(ctx, req.Username)
	if err != nil {
		if err == sql.ErrNoRows {
			ctx.JSON(http.StatusNotFound, errorResponse(err))
			return
		}
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	hashedInput := sha512.Sum512_256([]byte(req.Password))
	trimmedHash := bytes.Trim(hashedInput[:], "\x00")
	preparedPassword := string(trimmedHash)
	plainTextInBytes := []byte(preparedPassword)
	hashTextInBytes := []byte(user.Password)
	err = bcrypt.CompareHashAndPassword(hashTextInBytes, plainTextInBytes)
	if err != nil {
		ctx.JSON(http.StatusUnauthorized, errorResponse(err))
		return
	}

	expirationTime := time.Now().Add(100 * time.Minute)

	claims := &Claims{
		Username: req.Username,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expirationTime),
		},
	}

	generatedToken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	var jwtSignedKey = []byte("secret_key")
	generatedTokenToString, err := generatedToken.SignedString(jwtSignedKey)
	if err != nil {
		ctx.JSON(http.StatusInternalServerError, errorResponse(err))
		return
	}

	ctx.JSON(http.StatusOK, gin.H{"token": generatedTokenToString})
}

func TestServerLogin(t *testing.T) {
	gin.SetMode(gin.TestMode)

	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("Failed to open mock sql db, %s", err)
	}
	defer db.Close()

	store := &SQLStore{db: db, Queries: &Queries{db: db}}
	server := &Server{store: store, router: gin.Default()}

	tests := []struct {
		name           string
		setup          func()
		requestBody    string
		expectedStatus int
	}{
		{
			name: "Successful Login",
			setup: func() {
				mock.ExpectQuery("^SELECT (.+) FROM users WHERE username=?").
					WithArgs("validuser").
					WillReturnRows(sqlmock.NewRows([]string{"id", "username", "password", "email", "created_at"}).
						AddRow(1, "validuser", "$2a$10$H8iJ0", "email@example.com", time.Now()))
			},
			requestBody:    `{"username": "validuser", "password": "correctpass"}`,
			expectedStatus: http.StatusOK,
		},
		{
			name: "Invalid Username",
			setup: func() {
				mock.ExpectQuery("^SELECT (.+) FROM users WHERE username=?").
					WithArgs("invaliduser").
					WillReturnError(sql.ErrNoRows)
			},
			requestBody:    `{"username": "invaliduser", "password": "any"}`,
			expectedStatus: http.StatusNotFound,
		},
		{
			name: "Incorrect Password",
			setup: func() {
				mock.ExpectQuery("^SELECT (.+) FROM users WHERE username=?").
					WithArgs("validuser").
					WillReturnRows(sqlmock.NewRows([]string{"id", "username", "password", "email", "created_at"}).
						AddRow(1, "validuser", "$2a$10$H8iJ0", "email@example.com", time.Now()))
			},
			requestBody:    `{"username": "validuser", "password": "wrongpass"}`,
			expectedStatus: http.StatusUnauthorized,
		},
		{
			name: "Password Hash Comparison Error",
			setup: func() {
				mock.ExpectQuery("^SELECT (.+) FROM users WHERE username=?").
					WithArgs("validuser").
					WillReturnRows(sqlmock.NewRows([]string{"id", "username", "password", "email", "created_at"}).
						AddRow(1, "validuser", "malformedhash", "email@example.com", time.Now()))
			},
			requestBody:    `{"username": "validuser", "password": "correctpass"}`,
			expectedStatus: http.StatusUnauthorized,
		},
		{
			name: "JWT Token Generation Error",
			setup: func() {
				mock.ExpectQuery("^SELECT (.+) FROM users WHERE username=?").
					WithArgs("validuser").
					WillReturnRows(sqlmock.NewRows([]string{"id", "username", "password", "email", "created_at"}).
						AddRow(1, "validuser", "$2a$10$H8iJ0", "email@example.com", time.Now()))
			},
			requestBody:    `{"username": "validuser", "password": "correctpass"}`,
			expectedStatus: http.StatusInternalServerError,
		},
		{
			name: "Invalid JSON Request Body",
			setup: func() {},
			requestBody:    `{"username": "validuser", "password": "correctpass"}`,
			expectedStatus: http.StatusBadRequest,
		},
		{
			name: "Database Connection Error",
			setup: func() {
				mock.ExpectQuery("^SELECT (.+) FROM users WHERE username=?").
					WithArgs("validuser").
					WillReturnError(sql.ErrConnDone)
			},
			requestBody:    `{"username": "validuser", "password": "correctpass"}`,
			expectedStatus: http.StatusInternalServerError,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.setup()

			req, err := http.NewRequest(http.MethodPost, "/login", bytes.NewBufferString(tt.requestBody))
			if err != nil {
				t.Fatalf("Failed to create request: %s", err)
			}
			req.Header.Set("Content-Type", "application/json")

			recorder := httptest.NewRecorder()

			ctx, _ := gin.CreateTestContext(recorder)
			ctx.Request = req

			server.login(ctx)

			if recorder.Code != tt.expectedStatus {
				t.Errorf("Expected status %d, got %d", tt.expectedStatus, recorder.Code)
			}
		})
	}
}
