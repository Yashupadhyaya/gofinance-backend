// ********RoostGPT********
/*
Test generated by RoostGPT for test go-single-testfile using AI Type Claude AI and AI Model claude-3-5-sonnet-20240620

ROOST_METHOD_HASH=RandomString_d7e3599ac4
ROOST_METHOD_SIG_HASH=RandomString_c6fe4ad19a

Based on the provided function RandomString, here are several test scenarios:

Scenario 1: Generate a Random String of Specified Length

Details:
  Description: This test verifies that the RandomString function generates a string of the exact length specified by the input parameter.
Execution:
  Arrange: Define a desired length for the random string.
  Act: Call RandomString with the defined length.
  Assert: Check that the returned string's length matches the input parameter.
Validation:
  The assertion ensures that the function correctly generates a string of the specified length. This is crucial for applications that require precise string lengths for various purposes such as generating unique identifiers or passwords.

Scenario 2: Verify Character Set Used in Random String

Details:
  Description: This test checks that the RandomString function only uses characters from the predefined alphabet.
Execution:
  Arrange: Define a sufficiently long length to ensure a good sample size.
  Act: Generate a random string using RandomString.
  Assert: Verify that every character in the generated string is present in the alphabet.
Validation:
  This test ensures that the function adheres to the specified character set, which is important for maintaining consistency and meeting any character restrictions in the application's requirements.

Scenario 3: Test with Zero Length Input

Details:
  Description: This test checks the behavior of RandomString when given a zero as input.
Execution:
  Arrange: No specific arrangement needed.
  Act: Call RandomString with 0 as the input.
  Assert: Verify that an empty string is returned.
Validation:
  This edge case test ensures that the function handles zero-length requests gracefully, which is important for robustness and preventing unexpected behavior in the application.

Scenario 4: Test with Large Input Value

Details:
  Description: This test verifies that RandomString can handle generating very long strings.
Execution:
  Arrange: Define a very large number (e.g., 1,000,000) as the input.
  Act: Call RandomString with the large number.
  Assert: Check that the returned string has the exact large length specified and that it doesn't cause any performance issues or crashes.
Validation:
  This test ensures that the function can handle extreme cases without breaking, which is important for scalability and reliability in applications that might require very long random strings.

Scenario 5: Verify Randomness of Generated Strings

Details:
  Description: This test checks that multiple calls to RandomString with the same length parameter produce different strings.
Execution:
  Arrange: Define a reasonable length and number of iterations.
  Act: Call RandomString multiple times with the same length parameter.
  Assert: Verify that each generated string is unique.
Validation:
  This test ensures that the function produces sufficiently random results, which is crucial for applications requiring unique or unpredictable string generation, such as for security tokens or identifiers.

Scenario 6: Test with Negative Input Value

Details:
  Description: This test checks the behavior of RandomString when given a negative number as input.
Execution:
  Arrange: No specific arrangement needed.
  Act: Call RandomString with a negative number (e.g., -5).
  Assert: Verify that an empty string is returned or that the function handles the invalid input appropriately (e.g., by returning an error if the function is modified to do so).
Validation:
  This edge case test ensures that the function handles invalid inputs gracefully, preventing unexpected behavior or crashes in the application when misused.

These test scenarios cover various aspects of the RandomString function, including normal operation, edge cases, and potential error conditions. They aim to ensure the function's correctness, robustness, and adherence to expected behavior across different input scenarios.
*/

// ********RoostGPT********
package util

import (
	"math/rand"
	"strings"
	"testing"
	"time"
)

const testAlphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

func TestRandomString(t *testing.T) {
	// Seed the random number generator for consistent test results
	rand.Seed(time.Now().UnixNano())

	tests := []struct {
		name     string
		length   int
		wantLen  int
		wantFunc func(string) bool
	}{
		{
			name:    "Generate a Random String of Specified Length",
			length:  10,
			wantLen: 10,
			wantFunc: func(s string) bool {
				return len(s) == 10
			},
		},
		{
			name:    "Verify Character Set Used in Random String",
			length:  100,
			wantLen: 100,
			wantFunc: func(s string) bool {
				for _, c := range s {
					if !strings.ContainsRune(testAlphabet, c) {
						return false
					}
				}
				return true
			},
		},
		{
			name:    "Test with Zero Length Input",
			length:  0,
			wantLen: 0,
			wantFunc: func(s string) bool {
				return len(s) == 0
			},
		},
		{
			name:    "Test with Large Input Value",
			length:  1000000,
			wantLen: 1000000,
			wantFunc: func(s string) bool {
				return len(s) == 1000000
			},
		},
		{
			name:    "Verify Randomness of Generated Strings",
			length:  10,
			wantLen: 10,
			wantFunc: func(s string) bool {
				// Generate another string of the same length
				s2 := RandomString(10)
				return s != s2
			},
		},
		{
			name:    "Test with Negative Input Value",
			length:  -5,
			wantLen: 0,
			wantFunc: func(s string) bool {
				return len(s) == 0
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := RandomString(tt.length)
			if len(got) != tt.wantLen {
				t.Errorf("RandomString(%d) got length = %v, want %v", tt.length, len(got), tt.wantLen)
			}
			if !tt.wantFunc(got) {
				t.Errorf("RandomString(%d) = %v, failed additional validation", tt.length, got)
			}
		})
	}
}
