// ********RoostGPT********
/*
Test generated by RoostGPT for test go-single-tes-file using AI Type Open AI and AI Model gpt-4o

ROOST_METHOD_HASH=RandomEmail_1905439733
ROOST_METHOD_SIG_HASH=RandomEmail_7a04f189fd

Here are several test scenarios for the `RandomEmail` function, which generates a random email address using a random string of a specified length:

### Scenario 1: Generate Email with Standard Length

**Details:**
- **Description:** This test checks if the `RandomEmail` function correctly generates an email address with a random string of a specified standard length.
- **Execution:**
  - **Arrange:** Choose a typical length (e.g., 10) for the random string.
  - **Act:** Call `RandomEmail(10)`.
  - **Assert:** Verify that the result is a string ending with `@email.com` and has a total length of `10 + len("@email.com")`.
- **Validation:**
  - **Assertion Choice:** Check that the length of the email is as expected and the format is correct.
  - **Importance:** Ensures the function produces correctly formatted email addresses for typical input lengths.

### Scenario 2: Generate Email with Zero Length

**Details:**
- **Description:** This test examines the function's behavior when generating an email with a random string of zero length.
- **Execution:**
  - **Arrange:** Set the string length to zero.
  - **Act:** Call `RandomEmail(0)`.
  - **Assert:** Verify that the result is `@email.com`.
- **Validation:**
  - **Assertion Choice:** Check for the exact match with `@email.com`.
  - **Importance:** Confirms that the function handles the edge case of zero-length input gracefully.

### Scenario 3: Generate Email with Extremely Long Length

**Details:**
- **Description:** This test evaluates the function's ability to handle very large input lengths without crashing or misbehaving.
- **Execution:**
  - **Arrange:** Choose an extremely large length (e.g., 1000).
  - **Act:** Call `RandomEmail(1000)`.
  - **Assert:** Verify that the result is a string ending with `@email.com` and has a total length of `1000 + len("@email.com")`.
- **Validation:**
  - **Assertion Choice:** Check the length and format.
  - **Importance:** Ensures robustness and performance under heavy load conditions.

### Scenario 4: Generate Email with Negative Length

**Details:**
- **Description:** This test investigates how the function behaves with negative input values, which are logically invalid for a string length.
- **Execution:**
  - **Arrange:** Set the length to a negative value (e.g., -5).
  - **Act:** Call `RandomEmail(-5)`.
  - **Assert:** Verify the behavior, which could be an empty string with `@email.com` or handling this as an error.
- **Validation:**
  - **Assertion Choice:** Determine expected behavior based on function design (e.g., error handling or default behavior).
  - **Importance:** Validates input validation and error handling capabilities.

### Scenario 5: Generate Email with Special Characters Handling

**Details:**
- **Description:** This test checks if the random string part of the email contains only valid characters and no special characters that are not allowed in email addresses.
- **Execution:**
  - **Arrange:** Set up a reasonable string length (e.g., 15).
  - **Act:** Call `RandomEmail(15)`.
  - **Assert:** Verify that the generated part before `@` contains only alphanumeric characters.
- **Validation:**
  - **Assertion Choice:** Regular expression to match valid email local part.
  - **Importance:** Ensures generated emails are valid and usable in typical scenarios.

These scenarios cover a range of normal and edge cases for the `RandomEmail` function, ensuring its robustness and correctness in various situations.
*/

// ********RoostGPT********
package util

import (
	"regexp"
	"testing"
)

// Testrandom_randomemail tests the RandomEmail function for various scenarios
func Testrandom_randomemail(t *testing.T) {
	// Define test cases using a table-driven approach
	testCases := []struct {
		name        string
		inputLength int
		expectedLen int
		expectError bool
	}{
		{
			name:        "Generate Email with Standard Length",
			inputLength: 10,
			expectedLen: 10 + len("@email.com"),
			expectError: false,
		},
		{
			name:        "Generate Email with Zero Length",
			inputLength: 0,
			expectedLen: len("@email.com"),
			expectError: false,
		},
		{
			name:        "Generate Email with Extremely Long Length",
			inputLength: 1000,
			expectedLen: 1000 + len("@email.com"),
			expectError: false,
		},
		{
			name:        "Generate Email with Negative Length",
			inputLength: -5,
			expectedLen: len("@email.com"), // Assuming function handles negative as zero length
			expectError: false,
		},
		{
			name:        "Generate Email with Special Characters Handling",
			inputLength: 15,
			expectedLen: 15 + len("@email.com"),
			expectError: false,
		},
	}

	// Iterate over each test case
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Act
			result := RandomEmail(tc.inputLength)

			// Assert
			if len(result) != tc.expectedLen {
				t.Errorf("Test %s failed: expected length %d, got %d", tc.name, tc.expectedLen, len(result))
			}

			if tc.name == "Generate Email with Special Characters Handling" {
				// Check if the generated part before '@' contains only valid characters
				localPart := result[:len(result)-len("@email.com")]
				validCharRegex := "^[a-zA-Z0-9]+$"
				matched, err := regexp.MatchString(validCharRegex, localPart)
				if err != nil {
					t.Fatalf("Regex error: %v", err)
				}
				if !matched {
					t.Errorf("Test %s failed: local part contains invalid characters", tc.name)
				}
			}

			t.Logf("Test %s passed: generated email is %s", tc.name, result)
		})
	}
}
