// ********RoostGPT********
/*
Test generated by RoostGPT for test single-go-testfile using AI Type Open AI and AI Model gpt-4o-2024-05-13

ROOST_METHOD_HASH=RandomEmail_1905439733
ROOST_METHOD_SIG_HASH=RandomEmail_7a04f189fd

Certainly! Below are several test scenarios for the `RandomEmail` function, formatted as requested:

### Scenario 1: Generating Email with Standard Length
```
Scenario 1: Generating Email with Standard Length

Details:
  Description: This test checks if the function generates an email with the specified number of characters before the '@' symbol.
  Execution:
    Arrange: Set the input number to a typical length, e.g., 10.
    Act: Invoke the RandomEmail function with the input number.
    Assert: Verify that the email has the expected format and length.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Assert that the length of the local part (before '@') is equal to the input number.
      - Assert that the result ends with "@email.com".
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function adheres to the specified length, which is crucial for generating valid test data.
```

### Scenario 2: Generating Email with Zero Length
```
Scenario 2: Generating Email with Zero Length

Details:
  Description: This test checks the behavior of the function when the input number is zero.
  Execution:
    Arrange: Set the input number to 0.
    Act: Invoke the RandomEmail function with the input number.
    Assert: Verify that the email has the expected format and length.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Assert that the local part (before '@') is an empty string.
      - Assert that the result is "@email.com".
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function can handle edge cases where the input length is zero.
```

### Scenario 3: Generating Email with Negative Length
```
Scenario 3: Generating Email with Negative Length

Details:
  Description: This test checks the behavior of the function when the input number is negative.
  Execution:
    Arrange: Set the input number to a negative value, e.g., -5.
    Act: Invoke the RandomEmail function with the input number.
    Assert: Verify that the email has the expected format and length.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Assert that the function handles the negative input gracefully, potentially returning an empty local part.
      - Assert that the result is "@email.com".
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function is robust and can handle invalid inputs without crashing.
```

### Scenario 4: Generating Email with Large Length
```
Scenario 4: Generating Email with Large Length

Details:
  Description: This test checks if the function can handle a large input number and generates an appropriately long email.
  Execution:
    Arrange: Set the input number to a large value, e.g., 1000.
    Act: Invoke the RandomEmail function with the input number.
    Assert: Verify that the email has the expected format and length.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Assert that the length of the local part (before '@') is equal to the input number.
      - Assert that the result ends with "@email.com".
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function can handle large inputs, which is important for stress testing and performance evaluation.
```

### Scenario 5: Generating Multiple Emails to Check Uniqueness
```
Scenario 5: Generating Multiple Emails to Check Uniqueness

Details:
  Description: This test checks if the function generates unique emails when called multiple times with the same input number.
  Execution:
    Arrange: Set the input number to a typical length, e.g., 10. Determine how many emails to generate, e.g., 100.
    Act: Invoke the RandomEmail function multiple times and collect the results.
    Assert: Verify that all generated emails are unique.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Assert that the set of generated emails contains no duplicates.
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function generates unique emails, which is crucial for scenarios where unique identifiers are required.
```

### Scenario 6: Generating Email with Maximum Possible Length
```
Scenario 6: Generating Email with Maximum Possible Length

Details:
  Description: This test checks if the function can handle the maximum possible length for an email local part.
  Execution:
    Arrange: Set the input number to the maximum allowed length for an email local part, e.g., 64 characters.
    Act: Invoke the RandomEmail function with the input number.
    Assert: Verify that the email has the expected format and length.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Assert that the length of the local part (before '@') is equal to the input number.
      - Assert that the result ends with "@email.com".
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function adheres to email standards and can handle the maximum length allowed by the specification.
```

These scenarios cover a wide range of possible inputs and edge cases, ensuring that the `RandomEmail` function behaves as expected under various conditions.
*/

// ********RoostGPT********
// util/random_email_test.go

package util

import (
	"math/rand"
	"strings"
	"testing"
	"time"
)

// TestRandomEmail tests the RandomEmail function for various scenarios.
func TestRandomEmail(t *testing.T) {
	rand.Seed(time.Now().UnixNano())
	
	// Table-driven tests
	tests := []struct {
		name           string
		input          int
		expectedLength int
		expectedSuffix string
	}{
		{
			name:           "Standard Length",
			input:          10,
			expectedLength: 10,
			expectedSuffix: "@email.com",
		},
		{
			name:           "Zero Length",
			input:          0,
			expectedLength: 0,
			expectedSuffix: "@email.com",
		},
		{
			name:           "Negative Length",
			input:          -5,
			expectedLength: 0,
			expectedSuffix: "@email.com",
		},
		{
			name:           "Large Length",
			input:          1000,
			expectedLength: 1000,
			expectedSuffix: "@email.com",
		},
		{
			name:           "Maximum Possible Length",
			input:          64,
			expectedLength: 64,
			expectedSuffix: "@email.com",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			email := RandomEmail(tt.input)
			localPart := strings.Split(email, "@")[0]
			
			if len(localPart) != tt.expectedLength {
				t.Errorf("expected local part length %d, got %d", tt.expectedLength, len(localPart))
			}
			
			if !strings.HasSuffix(email, tt.expectedSuffix) {
				t.Errorf("expected email suffix %s, got %s", tt.expectedSuffix, email)
			}
			
			t.Logf("Test %s passed: generated email %s", tt.name, email)
		})
	}

	// Scenario to check uniqueness of generated emails
	t.Run("Multiple Emails Uniqueness", func(t *testing.T) {
		emailSet := make(map[string]bool)
		numEmails := 100
		length := 10
		
		for i := 0; i < numEmails; i++ {
			email := RandomEmail(length)
			if emailSet[email] {
				t.Errorf("duplicate email found: %s", email)
			}
			emailSet[email] = true
		}
		
		t.Logf("All %d generated emails are unique", numEmails)
	})
}

// util/random_string.go

package util

import (
	"math/rand"
	"strings"
)

const alphabet = "abcdefghijklmnopqrstuvwxyz"

// RandomString generates a random string of the specified length.
func RandomString(number int) string {
	var sb strings.Builder
	k := len(alphabet)

	for i := 0; i < number; i++ {
		c := alphabet[rand.Intn(k)]
		sb.WriteByte(c)
	}

	return sb.String()
}

// util/random_email.go

package util

import (
	"fmt"
)

// RandomEmail generates a random email address with the local part of the specified length.
func RandomEmail(number int) string {
	return fmt.Sprintf("%s@email.com", RandomString(number))
}
