// ********RoostGPT********
/*
Test generated by RoostGPT for test single-go-testfile using AI Type Open AI and AI Model gpt-4o-2024-08-06

ROOST_METHOD_HASH=RandomString_d7e3599ac4
ROOST_METHOD_SIG_HASH=RandomString_c6fe4ad19a

Below are several test scenarios for the `RandomString` function, which generates a random string of a specified length using a predefined alphabet. These scenarios cover various aspects, including normal operation, edge cases, and potential issues.

### Scenario 1: Generate a Random String of Positive Length

**Details:**
- **Description:** This test checks if the function can generate a string of a specified positive length using the given alphabet.
- **Execution:**
  - **Arrange:** Determine a positive integer value for the length of the string (e.g., 10).
  - **Act:** Call `RandomString` with this integer.
  - **Assert:** Verify that the length of the returned string matches the specified input length.
- **Validation:**
  - **Assertion Choice:** Use `len()` to assert the length of the output string.
  - **Logic:** Ensures that the function respects the input parameter by generating a string of the correct length.
  - **Importance:** Confirms that the function meets a basic requirement of generating strings of the desired length.

### Scenario 2: Generate an Empty String for Zero Length

**Details:**
- **Description:** This test verifies that the function returns an empty string when the input length is zero.
- **Execution:**
  - **Arrange:** Use zero as the input length.
  - **Act:** Call `RandomString(0)`.
  - **Assert:** Check that the returned string is empty.
- **Validation:**
  - **Assertion Choice:** Compare the returned string to an empty string (`""`).
  - **Logic:** Ensures that the function handles the edge case of zero length correctly.
  - **Importance:** Validates the function's behavior with boundary input, ensuring robustness.

### Scenario 3: Consistent Randomness with Seeded Random Generator

**Details:**
- **Description:** This test examines whether seeding the random number generator results in consistent output across multiple runs.
- **Execution:**
  - **Arrange:** Set a specific seed value using `rand.Seed()`.
  - **Act:** Generate a random string with a fixed length multiple times.
  - **Assert:** Confirm that the same string is produced each time.
- **Validation:**
  - **Assertion Choice:** Compare the outputs of consecutive runs.
  - **Logic:** Demonstrates that the random generator's seeding affects the output.
  - **Importance:** Useful for testing and debugging where deterministic behavior is required.

### Scenario 4: Generate String with Maximum Length

**Details:**
- **Description:** This test checks if the function can handle generating a string with a very large length.
- **Execution:**
  - **Arrange:** Choose a large integer value (e.g., 1,000,000).
  - **Act:** Call `RandomString` with this value.
  - **Assert:** Verify that the length of the output string matches the input.
- **Validation:**
  - **Assertion Choice:** Use `len()` to assert the length of the output string.
  - **Logic:** Tests the function's performance and memory handling capabilities.
  - **Importance:** Ensures that the function can handle large input sizes without crashing or misbehaving.

### Scenario 5: Validate Character Set Usage

**Details:**
- **Description:** This test ensures that the generated string only contains characters from a predefined alphabet.
- **Execution:**
  - **Arrange:** Define the alphabet used in the function.
  - **Act:** Generate a random string.
  - **Assert:** Check that each character in the string is part of the alphabet.
- **Validation:**
  - **Assertion Choice:** Iterate through the string and verify membership in the alphabet set.
  - **Logic:** Confirms that the function uses the correct character set.
  - **Importance:** Ensures the integrity of the generated string, which is crucial for applications relying on specific character sets.

### Scenario 6: Handle Negative Length Input Gracefully

**Details:**
- **Description:** This test verifies the function's behavior when given a negative length, expecting it to return an empty string or handle it gracefully.
- **Execution:**
  - **Arrange:** Use a negative integer as input.
  - **Act:** Call `RandomString` with this negative value.
  - **Assert:** Check that the returned string is empty or verify the function's handling mechanism.
- **Validation:**
  - **Assertion Choice:** Compare the result to an empty string.
  - **Logic:** Ensures the function handles invalid input without crashing.
  - **Importance:** Validates robustness and error handling, preventing unexpected behavior in production.

These scenarios aim to comprehensively test the `RandomString` function, ensuring its correct functionality across a variety of conditions and inputs.
*/

// ********RoostGPT********
package util

import (
	"math/rand"
	"strings"
	"testing"
	"time"
)

var alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"

// RandomString generates a random string of a specified length
func RandomString(number int) string {
	var sb strings.Builder
	k := len(alphabet)

	for i := 0; i < number; i++ {
		c := alphabet[rand.Intn(k)]
		sb.WriteByte(c)
	}

	return sb.String()
}

// Testrandomstring tests the RandomString function for various scenarios.
func Testrandomstring(t *testing.T) {
	// Seed the random number generator for consistent results in tests
	rand.Seed(time.Now().UnixNano())

	type testCase struct {
		name      string
		length    int
		expected  string
		checkFunc func(string, string) bool
	}

	// Define test cases for various scenarios
	testCases := []testCase{
		{
			name:     "Generate a Random String of Positive Length",
			length:   10,
			expected: "length 10",
			checkFunc: func(got, _ string) bool {
				return len(got) == 10
			},
		},
		{
			name:     "Generate an Empty String for Zero Length",
			length:   0,
			expected: "",
			checkFunc: func(got, expected string) bool {
				return got == expected
			},
		},
		{
			name:     "Consistent Randomness with Seeded Random Generator",
			length:   10,
			expected: "consistent output",
			checkFunc: func(got, _ string) bool {
				rand.Seed(42) // fixed seed for deterministic output
				firstOutput := RandomString(10)
				rand.Seed(42) // reseed to verify consistency
				secondOutput := RandomString(10)
				return firstOutput == secondOutput
			},
		},
		{
			name:     "Generate String with Maximum Length",
			length:   1000000, // 1,000,000
			expected: "length 1000000",
			checkFunc: func(got, _ string) bool {
				return len(got) == 1000000
			},
		},
		{
			name:     "Validate Character Set Usage",
			length:   50,
			expected: "valid characters",
			checkFunc: func(got, _ string) bool {
				for _, char := range got {
					if !strings.ContainsRune(alphabet, char) {
						return false
					}
				}
				return true
			},
		},
		{
			name:     "Handle Negative Length Input Gracefully",
			length:   -5,
			expected: "",
			checkFunc: func(got, expected string) bool {
				return got == expected
			},
		},
	}

	// Execute each test case
	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			result := RandomString(tc.length)
			if !tc.checkFunc(result, tc.expected) {
				t.Errorf("Test %s failed: expected %s, got %s", tc.name, tc.expected, result)
			} else {
				t.Logf("Test %s passed", tc.name)
			}
		})
	}
}
