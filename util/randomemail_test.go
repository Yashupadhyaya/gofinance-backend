// ********RoostGPT********
/*
Test generated by RoostGPT for test single-go-testfile using AI Type Open AI and AI Model gpt-4o-2024-05-13

ROOST_METHOD_HASH=RandomEmail_1905439733
ROOST_METHOD_SIG_HASH=RandomEmail_7a04f189fd

### Test Scenarios for `RandomEmail` Function

#### Scenario 1: Valid Email with Standard Length

Details:
  Description: This test checks if the function generates a valid email address with a typical length for the local part.
  Execution:
    Arrange: Set the `number` parameter to a standard value like 10.
    Act: Invoke `RandomEmail(10)`.
    Assert: Verify that the returned string is a valid email address containing 10 characters before `@email.com`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Use regex to validate the email format.
      - Ensure the local part has exactly 10 characters.
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function correctly concatenates the random string with the email domain.

#### Scenario 2: Minimum Length Local Part

Details:
  Description: This test checks if the function handles the minimum length for the local part correctly.
  Execution:
    Arrange: Set the `number` parameter to 1.
    Act: Invoke `RandomEmail(1)`.
    Assert: Verify that the returned string is a valid email address containing 1 character before `@email.com`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Use regex to validate the email format.
      - Ensure the local part has exactly 1 character.
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function can handle edge cases of the smallest possible input size.

#### Scenario 3: Zero Length Local Part

Details:
  Description: This test checks if the function handles a zero-length local part, which is an edge case.
  Execution:
    Arrange: Set the `number` parameter to 0.
    Act: Invoke `RandomEmail(0)`.
    Assert: Verify that the returned string is `@email.com`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Check if the return value is exactly `@email.com`.
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function handles edge cases gracefully, even though it might not be a valid email.

#### Scenario 4: Large Length Local Part

Details:
  Description: This test checks if the function can handle a very large length for the local part.
  Execution:
    Arrange: Set the `number` parameter to 1000.
    Act: Invoke `RandomEmail(1000)`.
    Assert: Verify that the returned string is a valid email address containing 1000 characters before `@email.com`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Use regex to validate the email format.
      - Ensure the local part has exactly 1000 characters.
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function can handle large input sizes, which is crucial for robustness.

#### Scenario 5: Valid Email with Special Characters

Details:
  Description: This test checks if the function can generate a valid email address with special characters in the local part.
  Execution:
    Arrange: Set the `number` parameter to 10 and mock `RandomString` to return a string with special characters.
    Act: Invoke `RandomEmail(10)`.
    Assert: Verify that the returned string is a valid email address containing special characters before `@email.com`.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Use regex to validate the email format.
      - Ensure the local part contains special characters.
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function can handle special characters in the local part, which is valid in email addresses.

#### Scenario 6: Randomness of Email Addresses

Details:
  Description: This test checks if the function generates different email addresses on repeated calls.
  Execution:
    Arrange: Set the `number` parameter to a standard value like 10.
    Act: Invoke `RandomEmail(10)` multiple times.
    Assert: Verify that the returned email addresses are different.
  Validation:
    Explain the choice of assertion and the logic behind the expected result:
      - Ensure the local parts of the returned email addresses are different.
    Discuss the importance of the test in relation to the application's behavior or business requirements:
      - Ensures that the function generates truly random email addresses, which is important for use cases like testing or seeding databases.
*/

// ********RoostGPT********
package util

import (
	"fmt"
	"math/rand"
	"regexp"
	"testing"
	"time"
)

func RandomEmail(number int) string {
	return fmt.Sprintf("%s@email.com", RandomString(number))
}

var RandomString = func(number int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, number)
	for i := range b {
		b[i] = charset[rand.Intn(len(charset))]
	}
	return string(b)
}

func TestRandomEmail(t *testing.T) {
	// Ensure random seed for different outputs on each run
	rand.Seed(time.Now().UnixNano())

	// Define test cases
	testCases := []struct {
		name        string
		number      int
		expectedLen int
		expected    string
	}{
		{
			name:        "Valid Email with Standard Length",
			number:      10,
			expectedLen: 10,
			expected:    "^[a-zA-Z0-9]{10}@email.com$",
		},
		{
			name:        "Minimum Length Local Part",
			number:      1,
			expectedLen: 1,
			expected:    "^[a-zA-Z0-9]{1}@email.com$",
		},
		{
			name:        "Zero Length Local Part",
			number:      0,
			expectedLen: 0,
			expected:    "^@email.com$",
		},
		{
			name:        "Large Length Local Part",
			number:      1000,
			expectedLen: 1000,
			expected:    "^[a-zA-Z0-9]{1000}@email.com$",
		},
		// TODO: Add more test cases if required
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Act
			result := RandomEmail(tc.number)

			// Assert
			if len(result) != tc.expectedLen+10 { // +10 for "@email.com"
				t.Errorf("Expected email length %d but got %d", tc.expectedLen+10, len(result))
			}

			matched, err := regexp.MatchString(tc.expected, result)
			if err != nil {
				t.Fatalf("Error compiling regex: %v", err)
			}
			if !matched {
				t.Errorf("Expected email to match %s but got %s", tc.expected, result)
			}

			t.Logf("Success: %s", result)
		})
	}

	// Additional test for special characters in local part
	t.Run("Valid Email with Special Characters", func(t *testing.T) {
		// Arrange
		originalRandomString := RandomString
		defer func() { RandomString = originalRandomString }() // Restore original function after test

		RandomString = func(number int) string {
			return "abc!@#123$"
		}

		// Act
		result := RandomEmail(10)

		// Assert
		expected := "abc!@#123$@email.com"
		if result != expected {
			t.Errorf("Expected %s but got %s", expected, result)
		}

		matched, err := regexp.MatchString("^[a-zA-Z0-9!@#\\$]{10}@email.com$", result)
		if err != nil {
			t.Fatalf("Error compiling regex: %v", err)
		}
		if !matched {
			t.Errorf("Expected email to match regex but got %s", result)
		}

		t.Logf("Success: %s", result)
	})

	// Additional test for randomness of email addresses
	t.Run("Randomness of Email Addresses", func(t *testing.T) {
		// Arrange
		email1 := RandomEmail(10)
		email2 := RandomEmail(10)

		// Act & Assert
		if email1 == email2 {
			t.Errorf("Expected different emails but got same: %s", email1)
		}

		t.Logf("Success: %s and %s are different", email1, email2)
	})
}
