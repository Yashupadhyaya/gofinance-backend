// ********RoostGPT********
/*
Test generated by RoostGPT for test single-go-testfile using AI Type Open AI and AI Model gpt-4o-2024-05-13

ROOST_METHOD_HASH=RandomString_d7e3599ac4
ROOST_METHOD_SIG_HASH=RandomString_c6fe4ad19a

### Test Scenarios for `RandomString` Function

#### Scenario 1: Generating a Random String of Specific Length

**Details:**
- **Description:** This test checks if the function can generate a string of a specified length.
- **Execution:**
  - **Arrange:** Define the length of the random string to be generated.
  - **Act:** Call `RandomString` with the defined length.
  - **Assert:** Verify that the length of the generated string matches the specified length.
- **Validation:**
  - **Explain the choice of assertion:** Length check ensures the function respects the input parameter.
  - **Discuss the importance:** Ensures that the function adheres to the specified requirements, which is crucial for any application relying on specific string lengths.

#### Scenario 2: Generating a Random String of Zero Length

**Details:**
- **Description:** This test checks if the function can handle a request for a string of zero length and return an empty string.
- **Execution:**
  - **Arrange:** Set the length to zero.
  - **Act:** Call `RandomString` with zero.
  - **Assert:** Verify that the returned string is empty.
- **Validation:**
  - **Explain the choice of assertion:** Ensures the function handles edge cases gracefully.
  - **Discuss the importance:** Validates that the function does not break or return unexpected results when given edge case inputs.

#### Scenario 3: Generating a Random String with Negative Length

**Details:**
- **Description:** This test checks the function's behavior when a negative length is specified.
- **Execution:**
  - **Arrange:** Set the length to a negative value.
  - **Act:** Call `RandomString` with the negative value.
  - **Assert:** Verify that the function handles the input correctly, either by returning an empty string or through defined behavior (e.g., panic, error).
- **Validation:**
  - **Explain the choice of assertion:** Ensures robustness against invalid inputs.
  - **Discuss the importance:** Prevents potential undefined behavior or crashes in production.

#### Scenario 4: Generating a Random String with Maximum Length

**Details:**
- **Description:** This test checks if the function can handle the generation of a very large string.
- **Execution:**
  - **Arrange:** Define a very large length (e.g., 10000).
  - **Act:** Call `RandomString` with the large length.
  - **Assert:** Verify that the length of the generated string matches the specified large length.
- **Validation:**
  - **Explain the choice of assertion:** Length check ensures the function can handle large inputs.
  - **Discuss the importance:** Validates performance and memory usage for large inputs, crucial for high-load applications.

#### Scenario 5: Checking the Randomness of the Generated String

**Details:**
- **Description:** This test checks if the function generates different strings on consecutive calls with the same length.
- **Execution:**
  - **Arrange:** Define a specific length.
  - **Act:** Call `RandomString` multiple times with the same length.
  - **Assert:** Verify that the generated strings are different.
- **Validation:**
  - **Explain the choice of assertion:** Ensures that the function provides randomness.
  - **Discuss the importance:** Important for use cases where unique identifiers or unpredictable strings are required.

#### Scenario 6: Validating Characters in the Generated String

**Details:**
- **Description:** This test checks if the generated string contains only valid characters from the alphabet.
- **Execution:**
  - **Arrange:** Define a specific length.
  - **Act:** Call `RandomString` with the defined length.
  - **Assert:** Verify that each character in the generated string belongs to the alphabet.
- **Validation:**
  - **Explain the choice of assertion:** Ensures that the function does not produce invalid characters.
  - **Discuss the importance:** Critical for applications that rely on specific character sets, such as password generators.

#### Scenario 7: Consistency with Seeded Random Generator

**Details:**
- **Description:** This test checks if the function produces consistent results when the random generator is seeded.
- **Execution:**
  - **Arrange:** Seed the random generator and define a specific length.
  - **Act:** Call `RandomString` multiple times with the same length and seed.
  - **Assert:** Verify that the generated strings are consistent across calls.
- **Validation:**
  - **Explain the choice of assertion:** Ensures predictable outcomes when using a fixed seed.
  - **Discuss the importance:** Useful for reproducibility in testing and debugging scenarios.

These scenarios collectively cover normal operations, edge cases, and potential error conditions for the `RandomString` function. Each scenario ensures the function behaves as expected under various conditions, contributing to the overall robustness and reliability of the application.
*/

// ********RoostGPT********
package util

import (
	"math/rand"
	"testing"
	"time"
	"unicode"
)

func TestRandomString(t *testing.T) {

	// Utility function to validate if the string contains only alphabet characters
	isValidString := func(s string) bool {
		for _, c := range s {
			if !unicode.IsLetter(c) {
				return false
			}
		}
		return true
	}

	// Table-driven tests
	tests := []struct {
		name     string
		length   int
		expected int
		validate func(string) bool
	}{
		{
			name:     "Specific Length",
			length:   10,
			expected: 10,
			validate: func(s string) bool { return len(s) == 10 },
		},
		{
			name:     "Zero Length",
			length:   0,
			expected: 0,
			validate: func(s string) bool { return s == "" },
		},
		{
			name:     "Negative Length",
			length:   -5,
			expected: 0,
			validate: func(s string) bool { return s == "" },
		},
		{
			name:     "Maximum Length",
			length:   10000,
			expected: 10000,
			validate: func(s string) bool { return len(s) == 10000 },
		},
		{
			name:     "Randomness Check",
			length:   8,
			expected: 8,
			validate: func(s string) bool {
				anotherString := RandomString(8)
				return s != anotherString
			},
		},
		{
			name:     "Valid Characters",
			length:   15,
			expected: 15,
			validate: isValidString,
		},
		{
			name:     "Consistency with Seeded Random Generator",
			length:   12,
			expected: 12,
			validate: func(s string) bool {
				rand.Seed(1)
				firstString := RandomString(12)
				rand.Seed(1)
				secondString := RandomString(12)
				return firstString == secondString
			},
		},
	}

	// Execute each test case
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			// Reset the random seed for reproducibility
			rand.Seed(time.Now().UnixNano())

			// Act
			result := RandomString(test.length)

			// Assert
			if !test.validate(result) {
				t.Errorf("Test '%s' failed. Expected validation to pass, but it didn't. Got: %s", test.name, result)
			} else {
				t.Logf("Test '%s' passed successfully.", test.name)
			}
		})
	}
}
